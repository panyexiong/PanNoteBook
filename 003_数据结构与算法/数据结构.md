## 稀疏数组

### 处理方法

1. 记录数组一共有几行几列，有多少不同得值
2. 把具有不同值得元素得行列及值记录在一个小规模得数组中，从而缩小程序得规模

### 二维数组转稀疏数组的思路

1. 遍历原始得二位数组，得到有效数据得个数sum
2. 根据sum创建稀疏数组sparseArr int[sum+1] [3]
3. 讲二维数组的有效数据存入到稀疏数据中。

### 稀疏数组转二维数组的思路

1. 先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组，比如上面的chessArr2 =  int[n+1] [n+1]
2. 再读取稀疏数组后几行的数据，并赋值给原始的二维数组



## 队列 Queue

- 队列是一个有序列表，可以用数组或是链表来实现。
- 遵循先入先出的原则。

### 数组模拟队列

- 队列本身是有序列表，诺使用数组结构来存储队列额数据，用maxSize表示该队列的最大容量
- 因为队列的输出、输入是分别从前后端来处理的，因此需要两个变量front和rear分别记录队列的前后端的下标，front随着数据的输出而改变，而rear则是随着数据输入而改变。
- 我们将数据存入队列的时候称“addQueue”。



```java
package com.pan.queue;

/**
 * @author panyexiong
 * @date 2019/7/27 - 14:25
 */
public class ArrayQueue {
    private int[] arr;
    private int maxSize;
    private int front;
    private int rear;

    //创建队列的构造器
    public ArrayQueue(int arrMaxSize) {
        maxSize = arrMaxSize;
        arr = new int[maxSize];
        front = -1;
        rear = -1;
    }

    /**
     * 判断队列是否已满
     *
     * @return
     */
    public boolean isFull() {
        return rear == maxSize - 1;
    }

    /**
     * 判断队列是否为空
     *
     * @return
     */
    public boolean isEmpty() {
        return front == rear;
    }

    /**
     * 添加数据
     *
     * @param data
     */
    public void addData(int data) {
        //判断队列是否已满
        if (isFull()) {
            System.out.println("队列满不能加入数据");
            return;
        }
        //未满，添加数据
        rear++;
        arr[rear] = data;
    }

    /**
     * 取出数据,出队列
     *
     * @return
     */
    public int getData() {
        if (isEmpty()) {
            //抛出异常
            throw new RuntimeException("队列空，不能取数据");
        }
        front++;
        return arr[front];
    }

    /**
     * 遍历队列
     */
    public void showQueue() {
        //遍历
        if (isEmpty()) {
            System.out.println("队列为空");
            return;
        }
        for (int i = 0; i < arr.length; i++) {
            System.out.printf("arr[%d]=%d\n", i, arr[i]);
        }
    }

    /**
     * 显示队列的头数据
     *
     * @return
     */
    public int headData() {
        if (isEmpty()) {
            throw new RuntimeException("队列为空，没有数据");
        }
        return arr[front + 1];
    }
}
```

---

```java
package com.pan.queue;

import java.util.Scanner;

/**
 * @author panyexiong
 * @date 2019/7/27 - 14:18
 */
public class ArrayQueueTest {
    public static void main(String[] args) {
        //初始化一个队列
        ArrayQueue arrayQueue = new ArrayQueue(3);
        char key = ' ';
        Scanner scanner = new Scanner(System.in);
        boolean loop = true;
        while (loop) {
            System.out.println("s(show) : 显示队列");
            System.out.println("e(exit) : 退出程序");
            System.out.println("a(add) : 添加数据");
            System.out.println("g(get) : 取出数据");
            System.out.println("h(head) : 查看队列头数据");
            key = scanner.next().charAt(0);
            switch (key) {
                case 's':
                    arrayQueue.showQueue();
                    break;
                case 'a':
                    System.out.println("请输入一个数");
                    int value = scanner.nextInt();
                    arrayQueue.addData(value);
                    break;
                case 'g':
                    try {
                        int data = arrayQueue.getData();
                        System.out.println("取出的数据是：" + data);
                    } catch (Exception e) {
                        System.out.println(e.getMessage());
                    }
                    break;
                case 'h':
                    try {
                        int data = arrayQueue.headData();
                        System.out.println("队列头数据是：" + data);
                    } catch (Exception e) {
                        System.out.println(e.getMessage());
                    }
                    break;
                case 'e':
                    scanner.close();
                    loop = false;
                    break;
                default:
                    break;
            }
        }
        System.out.println("程序退出！！！");
    }
}
```

### 数组模拟环形队列

#### 思路：

1. front指针的含义：front就指向对象的对一个元素。front初始值为0。
2. rear指针的含义：rear指向队列的最后一个元素的后一个位置。rear初始值0。
3. 当队列满时，条件是：（rear+1）%maxSize == front
4. 当队列空时，条件是：rear == front
5. 队列中有效数据的个数 (rear+maxSize-front)%maxSize

```java
package com.pan.queue;

/**
 * @author panyexiong
 * @date 2019/7/27 - 14:25
 */
public class ArrayCircleQueue {
    private int[] arr;
    private int maxSize;
    /**
     * 队列头,front指向队列的第一个元素，初始值0
     */
    private int front;
    /**
     * 队列尾，rear指向队列的最后一个元素的后一个位置。rear初始值0。
     */
    private int rear;


    /**
     * 创建队列的构造器
     *
     * @param arrMaxSize
     */
    public ArrayCircleQueue(int arrMaxSize) {
        maxSize = arrMaxSize;
        arr = new int[maxSize];
        front = 0;
        rear = 0;
    }

    /**
     * 判断队列是否已满
     *
     * @return
     */
    public boolean isFull() {
        return (rear + 1) % maxSize == front;
    }

    /**
     * 判断队列是否为空
     *
     * @return
     */
    public boolean isEmpty() {
        return front == rear;
    }

    /**
     * 添加数据
     *
     * @param data
     */
    public void addData(int data) {
        //判断队列是否已满
        if (isFull()) {
            System.out.println("队列满不能加入数据");
            return;
        }
        //未满，添加数据
        arr[rear] = data;
        //将rear后移，这里需要考虑取模
        rear = (rear + 1) % maxSize;
    }

    /**
     * 取出数据,出队列
     *
     * @return
     */
    public int getData() {
        if (isEmpty()) {
            //抛出异常
            throw new RuntimeException("队列空，不能取数据");
        }
        //这里需要分析front是指向队列的第一个元素
        //先将front的值保存到临时变量中
        //然后将front后移
        //返回临时变量中的值
        int tmp = arr[front];
        front = (front + 1) % maxSize;
        return tmp;
    }

    /**
     * 遍历队列
     */
    public void showQueue() {
        //遍历
        if (isEmpty()) {
            System.out.println("队列为空");
            return;
        }
        //思路：从front开始遍历，遍历多少个元素
        //
        for (int i = front; i < front + getSum(); i++) {
            System.out.printf("arr[%d]=%d\n", i % maxSize, arr[i % maxSize]);
        }
    }

    /**
     * 得出当前队列的有效数据的个数
     *
     * @return
     */
    public int getSum() {
        return (rear + maxSize - front) % maxSize;
    }

    /**
     * 显示队列的头数据
     *
     * @return
     */
    public int headData() {
        if (isEmpty()) {
            throw new RuntimeException("队列为空，没有数据");
        }
        return arr[front];
    }

}

```

```java
package com.pan.queue;

import java.util.Scanner;

/**
 * @author panyexiong
 * @date 2019/7/27 - 14:18
 */
public class ArrayQueueTest {
    public static void main(String[] args) {
        //初始化一个队列,设置为4，其实队列中有效数据个数最大为3
        ArrayCircleQueue arrayCircleQueue = new ArrayCircleQueue(4);
        char key = ' ';
        Scanner scanner = new Scanner(System.in);
        boolean loop = true;
        while (loop) {
            System.out.println("s(show) : 显示队列");
            System.out.println("e(exit) : 退出程序");
            System.out.println("a(add) : 添加数据");
            System.out.println("g(get) : 取出数据");
            System.out.println("h(head) : 查看队列头数据");
            key = scanner.next().charAt(0);
            switch (key) {
                case 's':
                    arrayCircleQueue.showQueue();
                    break;
                case 'a':
                    System.out.println("请输入一个数");
                    int value = scanner.nextInt();
                    arrayCircleQueue.addData(value);
                    break;
                case 'g':
                    try {
                        int data = arrayCircleQueue.getData();
                        System.out.println("取出的数据是：" + data);
                    } catch (Exception e) {
                        System.out.println(e.getMessage());
                    }
                    break;
                case 'h':
                    try {
                        int data = arrayCircleQueue.headData();
                        System.out.println("队列头数据是：" + data);
                    } catch (Exception e) {
                        System.out.println(e.getMessage());
                    }
                    break;
                case 'e':
                    scanner.close();
                    loop = false;
                    break;
                default:
                    break;
            }
        }
        System.out.println("程序退出！！！");
    }
}
```



## 链表 Linked List

- 链表是有序链表。
- 链表的一个节点由两部分组成：data域、next域（指向下一个节点，保存的是其地址）。
- 最后一个节点的next域为null。
- 链表的个个节点在内存中不是连续存放的。
- 链表分带头结点，和不带头节点。

### 单向链表

#### 应用实例

使用带head的单向链表实现水浒英雄排行榜管理

1. 完成对英雄人物的增删改查操作
2. 第一种方法：直接添加在链表的尾部，不考虑排序
3. 第二种方式：根据排名，将英雄插入指定位置。

#### 第一种添加（不考虑排序）

##### 思路

- head节点：不存放具体的数据，作用就是表达单向链表的头
- 添加（创建）
  - 先创建一个head节点
  - 后面我们每添加一个节点，就直接加入到链表的最后。

##### 代码

节点类

```java
package com.pan.list;

/**
 * @author panyexiong
 * @date 2019/7/27 - 16:02
 */
public class HeroNode {
    private int num;
    private String name;
    private String nickName;
    private HeroNode nextNode;

    /**
     * 构造器
     */
    public HeroNode(int num, String name, String nickName) {
        this.num = num;
        this.name = name;
        this.nickName = nickName;
    }

    public int getNum() {
        return num;
    }

    public void setNum(int num) {
        this.num = num;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getNickName() {
        return nickName;
    }

    public void setNickName(String nickName) {
        this.nickName = nickName;
    }

    public HeroNode getNextNode() {
        return nextNode;
    }

    public void setNextNode(HeroNode nextNode) {
        this.nextNode = nextNode;
    }

    @Override
    public String toString() {
        return "HeroNode{" +
                "num=" + num +
                ", name='" + name + '\'' +
                ", nickName='" + nickName + '\'' +
                '}';
    }
}
```

链表类

```java
package com.pan.list;

/**
 * @author panyexiong
 * @date 2019/7/27 - 16:10
 */
public class SingleLinkedList {

    /**
     * 头节点
     */
    private HeroNode head = new HeroNode(0, "", "");


    /**
     * 添加节点
     * 当不考虑编号顺序时
     * 1.先找到当前链表的最后一个节点
     * 2.将最后一个节点的next域指向新的节点
     *
     * @param heroNode
     */
    public void addNode(HeroNode heroNode) {
        //因为head不能动，因此需要一个辅助变量temp
        HeroNode temp = head;
        //遍历链表，找到最后一个节点
        while (true) {
            if (temp.getNextNode() == null) {
                break;
            }
            //如果不是则将temp指针后移
            temp = temp.getNextNode();
        }
        temp.setNextNode(heroNode);
    }

    /**
     * 遍历链表
     */
    public void showList() {
        //判断链表是否为空
        if (head.getNextNode() == null) {
            System.out.println("链表为空");
            return;
        }
        HeroNode temp = head.getNextNode();
        while (true) {
            if (temp == null) {
                break;
            }
            System.out.println(temp);
            temp = temp.getNextNode();
        }
    }
}
```

测试类

```java
package com.pan.list;

/**
 * @author panyexiong
 * @date 2019/7/27 - 16:26
 */
public class SingleLinkedListTest {
    public static void main(String[] args) {
        HeroNode hero001 = new HeroNode(1, "宋江", "及时雨");
        HeroNode hero002 = new HeroNode(2, "卢俊义", "玉麒麟");
        HeroNode hero003 = new HeroNode(3, "吴用", "智多星");

        //创建一个链表
        SingleLinkedList singleLinkedList = new SingleLinkedList();

        singleLinkedList.addNode(hero001);
        singleLinkedList.addNode(hero002);
        singleLinkedList.addNode(hero003);

        singleLinkedList.showList();

    }
}

```

结果

```shell
Connected to the target VM, address: '127.0.0.1:50280', transport: 'socket'
HeroNode{num=1, name='宋江', nickName='及时雨'}
HeroNode{num=2, name='卢俊义', nickName='玉麒麟'}
HeroNode{num=3, name='吴用', nickName='智多星'}
Disconnected from the target VM, address: '127.0.0.1:50280', transport: 'socket'

Process finished with exit code 0
```

#### 第二种插入（插入时考虑排序）

##### 思路

- 首先找到新添加的节点的位置
- 新的节点的next域指向下一个节点
- 前一个节点的next域指向新的节点

##### 代码

```java
    /**
     * 添加节点，方式2
     * 插入时考虑顺序问题
     *
     * @param heroNode
     */
    public void addNode2(HeroNode heroNode) {
        HeroNode temp = head;
        boolean flag = false;
        while (true) {
            if (temp.getNextNode() == null) {
                //temp在链表的最后
                break;
            }
            if (temp.getNextNode().getNum() > heroNode.getNum()) {
                //位置找到，新节点放在temp 和temp.next之间
                break;
            }
            //编号存在
            else if (temp.getNextNode().getNum() == heroNode.getNum()) {
                flag = true;
                break;
            }
            temp = temp.getNextNode();
        }
        //判断flag值
        //不能添加，编号已经存在
        if (flag) {
            System.out.printf("此编号的英雄编号%d已存在，不能添加！！！\n",heroNode.getNum());
        }
        else {
            heroNode.setNextNode(temp.getNextNode());
            temp.setNextNode(heroNode);
        }
    }
```

```java
public class SingleLinkedListTest {
    public static void main(String[] args) {
        HeroNode hero001 = new HeroNode(1, "宋江", "及时雨");
        HeroNode hero002 = new HeroNode(2, "卢俊义", "玉麒麟");
        HeroNode hero003 = new HeroNode(3, "吴用", "智多星");
        HeroNode hero004 = new HeroNode(4, "林冲", "豹子头");

        //创建一个链表
        SingleLinkedList singleLinkedList = new SingleLinkedList();

        singleLinkedList.addNode2(hero004);
        singleLinkedList.addNode2(hero001);
        singleLinkedList.addNode2(hero003);
        singleLinkedList.addNode2(hero002);
        singleLinkedList.addNode2(hero001);

        singleLinkedList.showList();
    }
}

```





