# 说一下volatile关键字
1.  首先volatile关键字是Java虚拟机提供的最轻量级的同步机制。当一个变量被volatile修饰后，它具备三种特性：可见性，不保证原子性，禁止指令重排序。

2.  什么是可见性？
    1.  提到可见性就要说到Java内存模型JMM。Java虚拟机规范中试图定义了一种Java内存模型JMM来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一直的内存访问效果。
        1.  JMM规定所有的变量都存储在主内存中，每条线程还有自己的工作内存，，线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝。线程对变量的所有操作(读取、赋值)都必须在工作内存中进行，而不能直接读写主内存中的变量。不同线程之间无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。
        2.  JMM中的主内存与工作内存与Java内存区域中的Java堆、栈、方法区等并不是同一个层次的内存划分，这两者基本上是没有关系的。
    2.  如果一个变量num被volatile修饰。线程A在其自己的工作内存中，对这个变量的副本进行了修改，那么这个变量的副本会被立刻刷新到主内存中，而普通变量则做不到这一点。
    
3.  不保证原子性的体现？
    1.  原子性指的是一个操作或者多个操作要么全部执行并且执行过程中不会被任何因素打断，要么都不执行。
    2.  举了例子i++
        1.  线程A执行从主内存中将i的值=1读取并加载到自己的工作内存中，此时线程A阻塞。线程B开始执行，同样从主内存中将i的值=1读取并加载到自己的工作内存中，然后将变量副本+1，因为i被volatile修饰，所以会被立即刷新到主内存中i=2，此时线程B执行结束，线程A继续执行，因为线程A已经读取并加载了变量i，所以线程A的工作内存中的变量副本i还是为1，继续执行线程，将i=2刷新回主内存。最终i==2，但是i++执行了两次，理论上应该是3，所以出现了线程安全的问题。
    3.  Java内存模型JMM中定义了8中操作在Java虚拟机实现时必须是原子的。
        1.  lock(锁定)：作用于主内存的变量，它把一个变量标识为一条线程独占的状态。
        2.  unlock(解锁)：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量可以被其他线程锁定。
        3.  read(读取)：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便于随后的load动作操作。
        4.  load(加载)：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入到工作内存的副本中。
        5.  use(使用)：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎。每当虚拟机遇到一个需要使用到变量的的值的字节码指令时，将会执行这个操作。
        6.  assgin(赋值)：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。
        7.  store(存储)：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用。
        8.  write(写入)：作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。
    4.  原子整型，原子引用
        1.  

