# 集合类不安全问题

1. 故障现象

   ```java
       public static void main(String[] args) {
           List<String> list = new ArrayList<>();
           //Set<String> set = new HashSet<>();
           for (int i = 0; i < 30; i++) {
               new Thread(() -> {
                   list.add(UUID.randomUUID().toString().substring(0, 8));
                   System.out.println(list);
               }, String.valueOf(i)).start();
           }
       }
   
   
   ```

   

   java.util.ConcurrentModificationException：并发修改异常

2. 导致原因

   并发争抢修改导致

3. 解决方案

   1. ```java
      List<String> list = new Vector<>();
      ```

   2. ```java
      List<String> list = Collections.synchronizedList(new ArrayList<>());
      ```

   3. ```java
      List<String> list = new CopyOnWriteArrayList<>();
      Set<String> set = new CopyOnWriteArraySet<>();
      Map<String,String> map = new ConcurrentHashMap<>();
      ```
      
      详解第三种：
      
      CopyOnWriteArrayList源码分析
      
      ```java
      //add方法
      public boolean add(E e) {
          final ReentrantLock lock = this.lock;
          lock.lock();
          try {
              Object[] elements = getArray();
              int len = elements.length;
              Object[] newElements = Arrays.copyOf(elements, len + 1);
              newElements[len] = e;
              setArray(newElements);
              return true;
          } finally {
              lock.unlock();
          }
      }
      ```
      
      写时复制
      
      CopyOnWrite容器即写时复制的容器。往一个容器添加元素的时候，不直接往当前容器Object[]添加，而是先将当前容器Objec[]进行copy复制出一个新的容器Object[] newElements,然后将新的容器里添加元素，添加完元素后，再将原容器的引用指向新的容器setArray（newElements）；这样做的好处是可以CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。

4. 优化建议

